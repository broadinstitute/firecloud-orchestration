akka {
  loglevel = "INFO"

  log-dead-letters = 10
  log-dead-letters-during-shutdown = on

  # Log the complete configuration at INFO level when the actor system is started.
  # This is useful when you are uncertain of what configuration is used.
  log-config-on-start = off

  actor {
    debug {
      # enable DEBUG logging of all AutoReceiveMessages (Kill, PoisonPill et.c.)
      autoreceive = off
      # enable DEBUG logging of actor lifecycle changes
      lifecycle = off
      # enable DEBUG logging of subscription changes on the eventStream
      event-stream = off
    }
  }
}

spray.can {
  server {
    request-timeout = infinite
    parsing {
      max-content-length = 50m
    }
  }
  client {
    # The max time period that a client connection will be waiting for a response
    # before triggering a request timeout. The timer for this logic is not started
    # until the connection is actually in a state to receive the response, which
    # may be quite some time after the request has been received from the
    # application!
    # There are two main reasons to delay the start of the request timeout timer:
    # 1. On the host-level API with pipelining disabled:
    #    If the request cannot be sent immediately because all connections are
    #    currently busy with earlier requests it has to be queued until a
    #    connection becomes available.
    # 2. With pipelining enabled:
    #    The request timeout timer starts only once the response for the
    #    preceding request on the connection has arrived.
    # Set to `infinite` to completely disable request timeouts.
    request-timeout = 300 s

    # The time period within which the TCP connecting process must be completed.
    # Set to `infinite` to disable.
    connecting-timeout = 20 s

    parsing {
      # allow parsing of large responses from rawls (and others) DSDEEPB-2488
      max-content-length = 50m
    }
  }

  host-connector {
    # The maximum number of parallel connections that an `HttpHostConnector`
    # is allowed to establish to a host. Must be greater than zero.
    max-connections = 8

    # The maximum number of times an `HttpHostConnector` attempts to repeat
    # failed requests (if the request can be safely retried) before
    # giving up and returning an error.
    max-retries = 5

    # If this setting is enabled, the `HttpHostConnector` pipelines requests
    # across connections, otherwise only one single request can be "open"
    # on a particular HTTP connection.
    pipelining = on

  }
}

http {
  interface="0.0.0.0"
  port=8080
  timeoutSeconds = 10
}

methods {
  authPrefix="/api/v1"
}

workspace {
  model="model.json"
  authPrefix="/api"
  workspacesPath="/workspaces"
  entitiesPath="/workspaces/%s/%s/entities"
  importEntitiesPath="/workspaces/%s/%s/importEntities"
  workspacesEntitiesCopyPath="/workspaces/entities/copy"
  submissionsPath="/workspaces/%s/%s/submissions"
  submissionsIdPath="/workspaces/%s/%s/submissions/%s"
  overwriteGroupMembershipPath="/admin/groups/%s/members"
}

userprofile {
  authPrefix = "/api"
  setKey="/thurloe"
  get="/thurloe/%s/%s"
  getAll="/thurloe/%s"
  getQuery="/thurloe"
  delete="/thurloe/%s/%s"
}

nih {
  whitelistFile = "users.txt"
  rawlsGroupName = "testRealm"
//  rawlsGroupName = "dbGapAuthorizedUsers"
}
